/* Modules */
const { EOL } = require('os')
const Parser = require('tap-parser')
const path = require('path')

const serialize = require('./serialize')
const write = require('./write')

const tapJunit = args => {
  let testCase = null
  const testSuites = []
  const tap = new Parser()

  /* Helpers */
  const sanitizeString = (str = 'tap') => {
    const { name } = path.parse(str)

    return name.replace(/[^\w-_.]/g, '').trim()
  }

  const generateFileName = (str = 'tap') => {
    const { name, ext } = path.parse(str)

    // If the file already has an extension
    // Then just clean that up and return it
    if (ext) {
      return `${sanitizeString(name)}${ext}`
    }

    // If no extension exists then clean up the string
    // Then attach the .xml to it
    return `${sanitizeString(str)}.xml`
  }

  /**
   * Writes the tap.xml file
   * @param  {String} xml the xml string generated by the tap-parser events
   * @param  {Boolean} passing passing boolean to let us know that the tests are passing
   */
  const writeOutput = (xml, passing) => {
    const name = generateFileName(args.name)

    write(args.output, name, xml)
      .then(() => {
        console.log('Tap-Junit:', `Finished! ${name} created at -- ${args.output}${EOL}`)

        if (!passing) {
          console.error(new Error('Tap-Junit: Looks like some test suites failed'))
          process.exit(1)
        }
      }).catch(err => {
        console.error('Tap-Junit: There was an error writing the output:', err)
        process.exit(1)
      })
  }

  /**
   * Creates a new test object and pushes it into our suites
   * @param  {String} testInfo Test name
   * @return {Object} Returns the newly created test object
   */
  const newTest = ({ name = '', number }) => {
    const testName = name || args.name

    const recordedTest = {
      id: number,
      assertCount: 0,
      asserts: [],
      comments: 0,
      skipCount: 0,
      skipped: false,
      errorCount: 0,
      errors: [],
      failCount: 0,
      failAsserts: [],
      testName
    }

    testSuites.push(recordedTest)

    return recordedTest
  }

  const isSkipped = ({ raw }) => (/#\s?(SKIP)+/i).test(raw)

  /* Parser Event listening */

  // This is the ENITRE test event not just the inner asserts
  tap.on('plan', res => {
    console.log('PLAN', res)
    testCase = newTest(res)
    testCase.skipped = isSkipped(res)
  })

  // Someone used a console.log or t.comment in their tests
  tap.on('comment', res => {
    if (!testCase) {
      testCase = newTest(res)
    }
    testCase.comments++
  })

  tap.on('skip', res => {
    console.log('SKIP', res)
    res.skip = isSkipped(res)
  })

  // Event for each assert inside the current Test
  tap.on('assert', res => {
    if (!testCase) {
      testCase = newTest(res)
    }

    console.log('ASSERT', res)
    testCase.assertCount++
    // res.skip = isSkipped(res)
    testCase.asserts.push(res)
  })

  // Event for a assert failure
  // Optional param: {assert} which is just the assertion object
  tap.on('fail', assert => {
    testCase.failCount++
    testCase.failAsserts.push(assert)
  })

  tap.on('complete', output => {
    console.log('OUTPUT', output)
    console.log('TEST SUITES', testSuites)

    // const xmlString = serialize(testSuites, output, args.suite)

    // // If an output is specified then let's write our results to it
    // if (args.output) {
    //   return writeOutput(xmlString, output.ok)
    // }

    // return console.log(`${xmlString}${EOL}`)
  })

  return tap
}

module.exports = tapJunit
