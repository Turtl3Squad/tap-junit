/* Modules */

const path = require('path')
const parser = require('tap-out')
const through = require('through2')
const duplexer = require('duplexer2')
const { mkdirp, writeFile } = require('fs-extra')
const { EOL } = require('os')
const serialize = require('./serialize.js')

const tapJunit = args => {
  let testCase = null
  const out = through()
  const testSuites = []
  const tap = parser()
  const dup = duplexer(tap, out)

  /* Helpers */

  const sanitizeString = (str = 'tap') => str.replace(/[^\w-_]/g, '').trim()

  /**
   * Writes the tap.xml file
   * @param  {String} xml the xml string generated by the tap-parser events
   * @param  {Boolean} passing passing boolean to let us know that the tests are passing
   * @return {Null} No Return required
   */
  const writeOutput = (xml, passing) => {
    const name = sanitizeString(args.name)

    mkdirp(args.output, err => {
      if (err) {
        console.error('There was an error when tap-junit tried to create the output directory', err)
        process.exitCode = 1
      }
      writeFile(path.join(args.output, `${name}.xml`), xml, xmlErr => {
        if (xmlErr) {
          console.error('There was a write error when tap-junit tried to write your output file', xmlErr)
          process.exitCode = 1
        }
        process.stdout.write(`Finished! ${name}.xml created at: ${args.output}${EOL}`)
        if (!passing) {
          console.error(new Error('Looks like some test suites failed'))
          process.exitCode = 1
        }
      })
    })
  }

  /**
   * Creates a new test object and pushes it into our suites
   * @param  {String} testInfo Test name
   * @return {Object} Returns the newly created test object
   */
  const newTest = ({ name = '', number }) => {
    const testName = name || sanitizeString(args.name)

    const recordedTest = {
      id: number,
      assertCount: 0,
      asserts: [],
      comments: 0,
      skipCount: 0,
      skipped: false,
      errorCount: 0,
      errors: [],
      failCount: 0,
      failAsserts: [],
    testName}

    testSuites.push(recordedTest)

    return recordedTest
  }

  const isSkipped = ({ raw }) => (/#\s?(SKIP)+/).test(raw)

  /* Parser Event listening */

  // This is the ENITRE test event not just the inner asserts
  tap.on('test', res => {
    testCase = newTest(res)
    testCase.skipped = isSkipped(res)
  })

  // Someone used a console.log or t.comment in their tests
  tap.on('comment', res => {
    if (!testCase) {
      testCase = newTest(res)
    }
    testCase.comments++
  })

  // Event for each assert inside the current Test
  tap.on('assert', res => {
    if (!testCase) {
      testCase = newTest(res)
    }
    testCase.assertCount++
    res.skip = isSkipped(res)
    testCase.asserts.push(res)
  })

  // Event for a assert failure
  // Optional param: {assert} which is just the assertion object
  tap.on('fail', assert => {
    testCase.failCount++
    testCase.failAsserts.push(assert)
  })

  tap.on('output', output => {
    const xmlString = serialize(testSuites)

    out.push(xmlString)

    // Most likely an issue upstream
    if (output.plans.length < 1) {
      process.exitCode = 1
    }

    // If an output is specified then let's write our output to it
    if (args.output) {
      return writeOutput(xmlString, output.fail.length === 0)
    }

    return process.stdout.write(`${xmlString}${EOL}`)
  })

  return dup
}

module.exports = tapJunit
